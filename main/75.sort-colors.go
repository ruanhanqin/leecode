package main

import (
	"fmt"
)

/**

题目:
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序
使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

注意:
不能使用代码库中的排序函数来解决这道题。

示例:
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
进阶：

一个直观的解决方案是使用计数排序的两趟扫描算法。
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
你能想出一个仅使用常数空间的一趟扫描算法吗？

*/

func main() {
	nums := []int{2,0,2,1,1,0}
	sortColors(nums)
	fmt.Println(nums)
}

/**
方法1:
初看这道题，理解成就是简单的排序就能解决了，后面一想，如果标记的不是0，1，2改为字母或者其他的字符串啥的，就不行了。

这道题采用了，三指针的方法：
第一个指针l是指针中间位置，也就是1的位置的，从0开始。
第二个指针i是用于移动遍历的，也是从0开始。
第三个指针r是最右端的。

当数值等于中间的数的时候，则跳过，遍历指针+1
当数值等于左边的数的时候，将i与l指针指的数对换，同时l和i都进一位
当数值等于右边的数的时候，将i与r对换，同时r减一位（左移），i不动

时间复杂度：O(n)
空间复杂度：O(1)
*/
func sortColors(nums []int)  {
	numsLen := len(nums)

	if numsLen <= 0 {
		return
	}

	i := 0
	l := 0
	r := numsLen-1

	for i <= r {
		if nums[i] == 0 {
			nums[i],nums[l] = nums[l],nums[i]
			l++
			i++
		} else if nums[i] == 1{
			i++
		} else if nums[i] == 2{
			nums[i],nums[r] = nums[r],nums[i]
			r--
		}
	}

	return
}








